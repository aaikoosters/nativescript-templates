/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, Input, Optional, ElementRef, HostListener } from '@angular/core';
import { NativeDialogService } from './dialog-services';
import { NativeDialogRef } from './dialog-ref';
import * as i0 from "@angular/core";
import * as i1 from "./dialog-ref";
import * as i2 from "./dialog-services";
/**
 * Button that will close the current dialog.
 */
export class NativeDialogCloseDirective {
    constructor(
    // The dialog title directive is always used in combination with a `MatDialogRef`.
    // tslint:disable-next-line: lightweight-tokens
    dialogRef, _elementRef, _dialog) {
        this.dialogRef = dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
    }
    ngOnInit() {
        if (!this.dialogRef) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
        }
    }
    ngOnChanges(changes) {
        const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
        if (proxiedChange) {
            this.dialogResult = proxiedChange.currentValue;
        }
    }
    _onButtonClick() {
        // Determinate the focus origin using the click event, because using the FocusMonitor will
        // result in incorrect origins. Most of the time, close buttons will be auto focused in the
        // dialog, and therefore clicking the button won't result in a focus change. This means that
        // the FocusMonitor won't detect any origin change, and will always output `program`.
        this.dialogRef.close(this.dialogResult);
    }
}
NativeDialogCloseDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NativeDialogCloseDirective, deps: [{ token: i1.NativeDialogRef, optional: true }, { token: i0.ElementRef }, { token: i2.NativeDialogService }], target: i0.ɵɵFactoryTarget.Directive });
NativeDialogCloseDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: NativeDialogCloseDirective, selector: "[native-dialog-close], [nativeDialogClose]", inputs: { dialogResult: ["native-dialog-close", "dialogResult"], _matDialogClose: ["nativeDialogClose", "_matDialogClose"] }, host: { listeners: { "tap": "_onButtonClick()" } }, exportAs: ["nativeDialogClose"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NativeDialogCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[native-dialog-close], [nativeDialogClose]',
                    exportAs: 'nativeDialogClose',
                }]
        }], ctorParameters: function () { return [{ type: i1.NativeDialogRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }, { type: i2.NativeDialogService }]; }, propDecorators: { dialogResult: [{
                type: Input,
                args: ['native-dialog-close']
            }], _matDialogClose: [{
                type: Input,
                args: ['nativeDialogClose']
            }], _onButtonClick: [{
                type: HostListener,
                args: ['tap']
            }] } });
/**
 * Finds the closest MatDialogRef to an element by looking at the DOM.
 * @param element Element relative to which to look for a dialog.
 * @param openDialogs References to the currently-open dialogs.
 */
function getClosestDialog(element, openDialogs) {
    let view = element.nativeElement.parent;
    while (view && !Object.hasOwnProperty.call(view, '__ng_modal_id__')) {
        view = view.parent;
    }
    return view ? openDialogs.find((dialog) => dialog.id === view['__ng_modal_id__']) : null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLWNvbnRlbnQtZGlyZWN0aXZlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL2xpYi9jZGsvZGlhbG9nL2RpYWxvZy1jb250ZW50LWRpcmVjdGl2ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQXFCLFFBQVEsRUFBaUIsVUFBVSxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2SCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7O0FBRS9DOztHQUVHO0FBTUgsTUFBTSxPQUFPLDBCQUEwQjtJQU1yQztJQUNFLGtGQUFrRjtJQUNsRiwrQ0FBK0M7SUFDNUIsU0FBK0IsRUFDMUMsV0FBNkIsRUFDN0IsT0FBNEI7UUFGakIsY0FBUyxHQUFULFNBQVMsQ0FBc0I7UUFDMUMsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO1FBQzdCLFlBQU8sR0FBUCxPQUFPLENBQXFCO0lBQ25DLENBQUM7SUFFSixRQUFRO1FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsaUZBQWlGO1lBQ2pGLGdGQUFnRjtZQUNoRixnRkFBZ0Y7WUFDaEYsb0ZBQW9GO1lBQ3BGLG1DQUFtQztZQUNuQyxvRUFBb0U7WUFDcEUsSUFBSSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFFLENBQUM7U0FDaEY7SUFDSCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBRXJGLElBQUksYUFBYSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxZQUFZLEdBQUcsYUFBYSxDQUFDLFlBQVksQ0FBQztTQUNoRDtJQUNILENBQUM7SUFHRCxjQUFjO1FBQ1osMEZBQTBGO1FBQzFGLDJGQUEyRjtRQUMzRiw0RkFBNEY7UUFDNUYscUZBQXFGO1FBQ3JGLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUMxQyxDQUFDOzt1SEF6Q1UsMEJBQTBCOzJHQUExQiwwQkFBMEI7MkZBQTFCLDBCQUEwQjtrQkFMdEMsU0FBUzttQkFBQztvQkFDVCw4REFBOEQ7b0JBQzlELFFBQVEsRUFBRSw0Q0FBNEM7b0JBQ3RELFFBQVEsRUFBRSxtQkFBbUI7aUJBQzlCOzswQkFVSSxRQUFRO3VHQVBtQixZQUFZO3NCQUF6QyxLQUFLO3VCQUFDLHFCQUFxQjtnQkFFQSxlQUFlO3NCQUExQyxLQUFLO3VCQUFDLG1CQUFtQjtnQkErQjFCLGNBQWM7c0JBRGIsWUFBWTt1QkFBQyxLQUFLOztBQVVyQjs7OztHQUlHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxPQUF5QixFQUFFLFdBQW1DO0lBQ3RGLElBQUksSUFBSSxHQUFvQixPQUFPLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQztJQUV6RCxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxFQUFFO1FBQ25FLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0tBQ3BCO0lBRUQsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQzNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIE9wdGlvbmFsLCBTaW1wbGVDaGFuZ2VzLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZpZXcsIFZpZXdCYXNlIH0gZnJvbSAnQG5hdGl2ZXNjcmlwdC9jb3JlJztcbmltcG9ydCB7IE5hdGl2ZURpYWxvZ1NlcnZpY2UgfSBmcm9tICcuL2RpYWxvZy1zZXJ2aWNlcyc7XG5pbXBvcnQgeyBOYXRpdmVEaWFsb2dSZWYgfSBmcm9tICcuL2RpYWxvZy1yZWYnO1xuXG4vKipcbiAqIEJ1dHRvbiB0aGF0IHdpbGwgY2xvc2UgdGhlIGN1cnJlbnQgZGlhbG9nLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9kaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdbbmF0aXZlLWRpYWxvZy1jbG9zZV0sIFtuYXRpdmVEaWFsb2dDbG9zZV0nLFxuICBleHBvcnRBczogJ25hdGl2ZURpYWxvZ0Nsb3NlJyxcbn0pXG5leHBvcnQgY2xhc3MgTmF0aXZlRGlhbG9nQ2xvc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIC8qKiBEaWFsb2cgY2xvc2UgaW5wdXQuICovXG4gIEBJbnB1dCgnbmF0aXZlLWRpYWxvZy1jbG9zZScpIGRpYWxvZ1Jlc3VsdDogYW55O1xuXG4gIEBJbnB1dCgnbmF0aXZlRGlhbG9nQ2xvc2UnKSBfbWF0RGlhbG9nQ2xvc2U6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgZGlhbG9nIHRpdGxlIGRpcmVjdGl2ZSBpcyBhbHdheXMgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGEgYE1hdERpYWxvZ1JlZmAuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBsaWdodHdlaWdodC10b2tlbnNcbiAgICBAT3B0aW9uYWwoKSBwdWJsaWMgZGlhbG9nUmVmOiBOYXRpdmVEaWFsb2dSZWY8YW55PixcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPFZpZXc+LFxuICAgIHByaXZhdGUgX2RpYWxvZzogTmF0aXZlRGlhbG9nU2VydmljZVxuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmRpYWxvZ1JlZikge1xuICAgICAgLy8gV2hlbiB0aGlzIGRpcmVjdGl2ZSBpcyBpbmNsdWRlZCBpbiBhIGRpYWxvZyB2aWEgVGVtcGxhdGVSZWYgKHJhdGhlciB0aGFuIGJlaW5nXG4gICAgICAvLyBpbiBhIENvbXBvbmVudCksIHRoZSBEaWFsb2dSZWYgaXNuJ3QgYXZhaWxhYmxlIHZpYSBpbmplY3Rpb24gYmVjYXVzZSBlbWJlZGRlZFxuICAgICAgLy8gdmlld3MgY2Fubm90IGJlIGdpdmVuIGEgY3VzdG9tIGluamVjdG9yLiBJbnN0ZWFkLCB3ZSBsb29rIHVwIHRoZSBEaWFsb2dSZWYgYnlcbiAgICAgIC8vIElELiBUaGlzIG11c3Qgb2NjdXIgaW4gYG9uSW5pdGAsIGFzIHRoZSBJRCBiaW5kaW5nIGZvciB0aGUgZGlhbG9nIGNvbnRhaW5lciB3b24ndFxuICAgICAgLy8gYmUgcmVzb2x2ZWQgYXQgY29uc3RydWN0b3IgdGltZS5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICB0aGlzLmRpYWxvZ1JlZiA9IGdldENsb3Nlc3REaWFsb2codGhpcy5fZWxlbWVudFJlZiwgdGhpcy5fZGlhbG9nLm9wZW5EaWFsb2dzKSE7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGNvbnN0IHByb3hpZWRDaGFuZ2UgPSBjaGFuZ2VzWydfbWF0RGlhbG9nQ2xvc2UnXSB8fCBjaGFuZ2VzWydfbWF0RGlhbG9nQ2xvc2VSZXN1bHQnXTtcblxuICAgIGlmIChwcm94aWVkQ2hhbmdlKSB7XG4gICAgICB0aGlzLmRpYWxvZ1Jlc3VsdCA9IHByb3hpZWRDaGFuZ2UuY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ3RhcCcpXG4gIF9vbkJ1dHRvbkNsaWNrKCkge1xuICAgIC8vIERldGVybWluYXRlIHRoZSBmb2N1cyBvcmlnaW4gdXNpbmcgdGhlIGNsaWNrIGV2ZW50LCBiZWNhdXNlIHVzaW5nIHRoZSBGb2N1c01vbml0b3Igd2lsbFxuICAgIC8vIHJlc3VsdCBpbiBpbmNvcnJlY3Qgb3JpZ2lucy4gTW9zdCBvZiB0aGUgdGltZSwgY2xvc2UgYnV0dG9ucyB3aWxsIGJlIGF1dG8gZm9jdXNlZCBpbiB0aGVcbiAgICAvLyBkaWFsb2csIGFuZCB0aGVyZWZvcmUgY2xpY2tpbmcgdGhlIGJ1dHRvbiB3b24ndCByZXN1bHQgaW4gYSBmb2N1cyBjaGFuZ2UuIFRoaXMgbWVhbnMgdGhhdFxuICAgIC8vIHRoZSBGb2N1c01vbml0b3Igd29uJ3QgZGV0ZWN0IGFueSBvcmlnaW4gY2hhbmdlLCBhbmQgd2lsbCBhbHdheXMgb3V0cHV0IGBwcm9ncmFtYC5cbiAgICB0aGlzLmRpYWxvZ1JlZi5jbG9zZSh0aGlzLmRpYWxvZ1Jlc3VsdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBNYXREaWFsb2dSZWYgdG8gYW4gZWxlbWVudCBieSBsb29raW5nIGF0IHRoZSBET00uXG4gKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHJlbGF0aXZlIHRvIHdoaWNoIHRvIGxvb2sgZm9yIGEgZGlhbG9nLlxuICogQHBhcmFtIG9wZW5EaWFsb2dzIFJlZmVyZW5jZXMgdG8gdGhlIGN1cnJlbnRseS1vcGVuIGRpYWxvZ3MuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3REaWFsb2coZWxlbWVudDogRWxlbWVudFJlZjxWaWV3Piwgb3BlbkRpYWxvZ3M6IE5hdGl2ZURpYWxvZ1JlZjxhbnk+W10pIHtcbiAgbGV0IHZpZXc6IFZpZXdCYXNlIHwgbnVsbCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnQ7XG5cbiAgd2hpbGUgKHZpZXcgJiYgIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZpZXcsICdfX25nX21vZGFsX2lkX18nKSkge1xuICAgIHZpZXcgPSB2aWV3LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiB2aWV3ID8gb3BlbkRpYWxvZ3MuZmluZCgoZGlhbG9nKSA9PiBkaWFsb2cuaWQgPT09IHZpZXdbJ19fbmdfbW9kYWxfaWRfXyddKSA6IG51bGw7XG59XG4iXX0=