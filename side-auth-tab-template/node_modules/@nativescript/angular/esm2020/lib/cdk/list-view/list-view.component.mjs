import { __decorate, __metadata } from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Host, HostListener, inject, Inject, InjectionToken, Input, IterableDiffers, Output, TemplateRef, ViewChild, ViewContainerRef } from '@angular/core';
import { LayoutBase, ObservableArray, profile } from '@nativescript/core';
import { extractSingleViewRecursive } from '../../element-registry/registry';
import { NativeScriptDebug } from '../../trace';
import { isListLikeIterable } from '../../utils/general';
import * as i0 from "@angular/core";
const NG_VIEW = '_ngViewRef';
export const TEMPLATED_ITEMS_COMPONENT = new InjectionToken('TemplatedItemsComponent');
export class ItemContext {
    constructor($implicit, item, index, even, odd) {
        this.$implicit = $implicit;
        this.item = item;
        this.index = index;
        this.even = even;
        this.odd = odd;
    }
}
export class NsTemplatedItem {
    constructor(template, location, onCreate) {
        this.template = template;
        this.location = location;
        this.onCreate = onCreate;
    }
    create(context) {
        const viewRef = this.location.createEmbeddedView(this.template, context ? this.setupItemContext(context) : new ItemContext());
        viewRef.detach(); // create detached, just beware this doesn't always work and the view might run the first CD anyway.
        const resultView = getItemViewRoot(viewRef);
        resultView[NG_VIEW] = viewRef;
        if (this.onCreate) {
            this.onCreate(resultView);
        }
        return resultView;
    }
    update(view, context) {
        const viewRef = this.getEmbeddedViewRef(view);
        this.setupItemContext(context, viewRef);
        viewRef?.detectChanges();
    }
    attach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.reattach();
        viewRef?.detectChanges();
    }
    detach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.detach();
    }
    dispose(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.destroy();
    }
    getEmbeddedViewRef(view) {
        let viewRef = view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!viewRef && view instanceof LayoutBase && view.getChildrenCount() > 0) {
            viewRef = view.getChildAt(0)[NG_VIEW];
        }
        return viewRef;
    }
    isValid(view) {
        return !!this.getEmbeddedViewRef(view);
    }
    setupItemContext({ index, data }, oldView) {
        const context = oldView ? oldView.context : new ItemContext();
        context.$implicit = data;
        context.item = data;
        context.index = index;
        context.even = index % 2 === 0;
        context.odd = !context.even;
        return context;
    }
}
export class ListViewComponent {
    get nativeElement() {
        return this.templatedItemsView;
    }
    get items() {
        return this._items;
    }
    set items(value) {
        this._items = value;
        let needDiffer = true;
        if (value instanceof ObservableArray) {
            needDiffer = false;
        }
        if (needDiffer && !this._differ && isListLikeIterable(value)) {
            this._differ = this._iterableDiffers.find(this._items).create((_index, item) => {
                return item;
            });
        }
        this.templatedItemsView.items = this._items;
    }
    // this elementRef is only here for backwards compatibility reasons
    constructor(_elementRef) {
        this._iterableDiffers = inject(IterableDiffers);
        this._changeDetectorRef = inject(ChangeDetectorRef);
        this._elementRef = inject(ElementRef);
        // I believe this only exists so this can be inherited and people can override it.
        this.templatedItemsView = this._elementRef.nativeElement;
        this._viewToTemplate = new WeakMap();
        this.setupItemView = new EventEmitter();
        if (_elementRef) {
            this.templatedItemsView = _elementRef.nativeElement;
        }
    }
    ngAfterContentInit() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
        }
        this.setItemTemplates();
    }
    ngOnDestroy() {
        this.templatedItemsView = null;
        if (this._templateMap) {
            this._templateMap.clear();
        }
    }
    setItemTemplates() {
        // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
        // so cache and use only the original template to avoid errors.
        this.fallbackItemTemplate = this.itemTemplateQuery;
        if (this.fallbackItemTemplate && !this._templateMap?.has('default')) {
            // apparently you can create a Core ListView without a template...
            // we also add a fallback default for when the user sets multiple templates but no templateSelector
            this.registerTemplate('default', this.fallbackItemTemplate);
        }
        if (this._templateMap) {
            // sometimes templates are registered before loader is ready, so we update here
            this._templateMap.forEach((t) => (t.location = this.loader));
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('Setting templates');
            }
            const templates = [];
            this._templateMap.forEach((value, key) => {
                templates.push({
                    createView: () => null,
                    key,
                });
            });
            this.templatedItemsView.itemTemplates = templates;
        }
    }
    registerTemplate(key, template) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog(`registerTemplate for key: ${key}, ${this.loader}`);
        }
        if (!this._templateMap) {
            this._templateMap = new Map();
        }
        this._templateMap.set(key, new NsTemplatedItem(template, this.loader, (v) => this._viewToTemplate.set(v, key)));
    }
    onItemLoading(args) {
        if (!this._templateMap) {
            return;
        }
        const index = args.index;
        const lview = args.object;
        const items = lview.items;
        const currentItem = 'getItem' in items && typeof items.getItem === 'function' ? items.getItem(index) : items[index];
        let template;
        if (args.view) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog(`onItemLoading: ${index} - Reusing existing view`);
            }
            let templateKey = this._viewToTemplate.get(args.view);
            if (!templateKey && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
                templateKey = this._viewToTemplate.get(args.view.getChildAt(0));
            }
            if (!templateKey) {
                // this template was not created by us
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`ViewReference not found for item ${index}. View recycling is not working`);
                }
                return;
            }
            template = this._templateMap.get(templateKey);
            template.update(args.view, { index, data: currentItem });
        }
        else {
            // this should never enter if it creates the view
            const templateKey = typeof lview.itemTemplateSelector === 'function' ? lview.itemTemplateSelector(currentItem, index, items) : 'default';
            template = this._templateMap.get(templateKey);
            if (!template) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`Template for key '${templateKey}' not found.`);
                }
                return;
            }
            args.view = template.create({ index, data: currentItem });
        }
        this.setupViewRef(template.getEmbeddedViewRef(args.view), currentItem, index, args.view);
        template.attach(args.view);
        this._changeDetectorRef.detectChanges();
    }
    setupViewRef(viewRef, data, index, nativeElement) {
        const context = viewRef.context;
        this.setupItemView.next({ view: viewRef, nativeElement, data: data, index: index, context: context });
    }
    ngDoCheck() {
        if (this._differ) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
            }
            const changes = this._differ.diff(this._items);
            if (changes) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                }
                this.templatedItemsView.refresh();
            }
        }
    }
}
ListViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
ListViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ListViewComponent, selector: "ListView", inputs: { items: "items" }, outputs: { setupItemView: "setupItemView" }, host: { listeners: { "itemLoading": "onItemLoading($event)" } }, providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }], queries: [{ propertyName: "itemTemplateQuery", first: true, predicate: TemplateRef, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "loader", first: true, predicate: ["loader"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ListViewComponent.prototype, "onItemLoading", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ListViewComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ListView',
                    template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { loader: [{
                type: ViewChild,
                args: ['loader', { read: ViewContainerRef, static: true }]
            }], setupItemView: [{
                type: Output
            }], itemTemplateQuery: [{
                type: ContentChild,
                args: [TemplateRef, { read: TemplateRef, static: false }]
            }], items: [{
                type: Input
            }], onItemLoading: [{
                type: HostListener,
                args: ['itemLoading', ['$event']]
            }] } });
export function getItemViewRoot(viewRef, rootLocator = extractSingleViewRecursive) {
    const rootView = rootLocator(viewRef.rootNodes, 0);
    return rootView;
}
// eslint-disable-next-line @angular-eslint/directive-selector
export class TemplateKeyDirective {
    constructor(templateRef, comp) {
        this.templateRef = templateRef;
        this.comp = comp;
    }
    set nsTemplateKey(value) {
        if (this.comp && this.templateRef) {
            this.comp.registerTemplate(value, this.templateRef);
        }
    }
    set nsTemplateKeys(values) {
        // single template with multiple keys
        if (this.comp && this.templateRef && values) {
            values.forEach((value) => this.comp.registerTemplate(value, this.templateRef));
        }
    }
}
TemplateKeyDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TemplateKeyDirective, deps: [{ token: i0.TemplateRef }, { token: TEMPLATED_ITEMS_COMPONENT, host: true }], target: i0.ɵɵFactoryTarget.Directive });
TemplateKeyDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: TemplateKeyDirective, selector: "[nsTemplateKey],[nsTemplateKeys]", inputs: { nsTemplateKey: "nsTemplateKey", nsTemplateKeys: "nsTemplateKeys" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: TemplateKeyDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nsTemplateKey],[nsTemplateKeys]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: undefined, decorators: [{
                    type: Host
                }, {
                    type: Inject,
                    args: [TEMPLATED_ITEMS_COMPONENT]
                }] }]; }, propDecorators: { nsTemplateKey: [{
                type: Input
            }], nsTemplateKeys: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdC12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL2xpYi9jZGsvbGlzdC12aWV3L2xpc3Qtdmlldy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBb0IsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQVcsVUFBVSxFQUFtQixZQUFZLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFrQixlQUFlLEVBQXFCLE1BQU0sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xXLE9BQU8sRUFBZ0MsVUFBVSxFQUFZLGVBQWUsRUFBRSxPQUFPLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUV4SCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUM3RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7O0FBRXpELE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQztBQU03QixNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLGNBQWMsQ0FBcUIseUJBQXlCLENBQUMsQ0FBQztBQUUzRyxNQUFNLE9BQU8sV0FBVztJQUN0QixZQUFtQixTQUFhLEVBQVMsSUFBUSxFQUFTLEtBQWMsRUFBUyxJQUFjLEVBQVMsR0FBYTtRQUFsRyxjQUFTLEdBQVQsU0FBUyxDQUFJO1FBQVMsU0FBSSxHQUFKLElBQUksQ0FBSTtRQUFTLFVBQUssR0FBTCxLQUFLLENBQVM7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFVO1FBQVMsUUFBRyxHQUFI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RUFBRTtZQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztTQUNoRjtJQUNILENBQUM7O2lIQWZVLG9CQUFvQiw2Q0FDa0MseUJBQXlCO3FHQUQvRSxvQkFBb0I7MkZBQXBCLG9CQUFvQjtrQkFEaEMsU0FBUzttQkFBQyxFQUFFLFFBQVEsRUFBRSxrQ0FBa0MsRUFBRTs7MEJBRVAsSUFBSTs7MEJBQUksTUFBTTsyQkFBQyx5QkFBeUI7NENBR3RGLGFBQWE7c0JBRGhCLEtBQUs7Z0JBT0YsY0FBYztzQkFEakIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgRG9DaGVjaywgRWxlbWVudFJlZiwgRW1iZWRkZWRWaWV3UmVmLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEhvc3QsIEhvc3RMaXN0ZW5lciwgaW5qZWN0LCBJbmplY3QsIEluamVjdGlvblRva2VuLCBJbnB1dCwgSXRlcmFibGVEaWZmZXIsIEl0ZXJhYmxlRGlmZmVycywgTmdab25lLCBPbkRlc3Ryb3ksIE91dHB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSXRlbUV2ZW50RGF0YSwgS2V5ZWRUZW1wbGF0ZSwgTGF5b3V0QmFzZSwgTGlzdFZpZXcsIE9ic2VydmFibGVBcnJheSwgcHJvZmlsZSwgVmlldyB9IGZyb20gJ0BuYXRpdmVzY3JpcHQvY29yZSc7XG5cbmltcG9ydCB7IGV4dHJhY3RTaW5nbGVWaWV3UmVjdXJzaXZlIH0gZnJvbSAnLi4vLi4vZWxlbWVudC1yZWdpc3RyeS9yZWdpc3RyeSc7XG5pbXBvcnQgeyBOYXRpdmVTY3JpcHREZWJ1ZyB9IGZyb20gJy4uLy4uL3RyYWNlJztcbmltcG9ydCB7IE5nVmlld1RlbXBsYXRlIH0gZnJvbSAnLi4vLi4vdmlldy1yZWZzJztcbmltcG9ydCB7IGlzTGlzdExpa2VJdGVyYWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2dlbmVyYWwnO1xuXG5jb25zdCBOR19WSUVXID0gJ19uZ1ZpZXdSZWYnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlZEl0ZW1zSG9zdDxUID0gYW55PiB7XG4gIHJlZ2lzdGVyVGVtcGxhdGUoa2V5OiBzdHJpbmcsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxUPik7XG59XG5cbmV4cG9ydCBjb25zdCBURU1QTEFURURfSVRFTVNfQ09NUE9ORU5UID0gbmV3IEluamVjdGlvblRva2VuPFRlbXBsYXRlZEl0ZW1zSG9zdD4oJ1RlbXBsYXRlZEl0ZW1zQ29tcG9uZW50Jyk7XG5cbmV4cG9ydCBjbGFzcyBJdGVtQ29udGV4dDxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ/OiBULCBwdWJsaWMgaXRlbT86IFQsIHB1YmxpYyBpbmRleD86IG51bWJlciwgcHVibGljIGV2ZW4/OiBib29sZWFuLCBwdWJsaWMgb2RkPzogYm9vbGVhbikge31cbn1cblxuZXhwb3J0IGNsYXNzIE5zVGVtcGxhdGVkSXRlbTxUPiBpbXBsZW1lbnRzIE5nVmlld1RlbXBsYXRlPHsgaW5kZXg6IG51bWJlcjsgZGF0YTogVCB9PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPEl0ZW1Db250ZXh0PFQ+PiwgcHVibGljIGxvY2F0aW9uOiBWaWV3Q29udGFpbmVyUmVmLCBwcml2YXRlIG9uQ3JlYXRlPzogKHZpZXc6IFZpZXcpID0+IHZvaWQpIHt9XG4gIGNyZWF0ZShjb250ZXh0PzogeyBpbmRleDogbnVtYmVyOyBkYXRhOiBUIH0pOiBWaWV3IHtcbiAgICBjb25zdCB2aWV3UmVmID0gdGhpcy5sb2NhdGlvbi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSwgY29udGV4dCA/IHRoaXMuc2V0dXBJdGVtQ29udGV4dChjb250ZXh0KSA6IG5ldyBJdGVtQ29udGV4dCgpKTtcbiAgICB2aWV3UmVmLmRldGFjaCgpOyAvLyBjcmVhdGUgZGV0YWNoZWQsIGp1c3QgYmV3YXJlIHRoaXMgZG9lc24ndCBhbHdheXMgd29yayBhbmQgdGhlIHZpZXcgbWlnaHQgcnVuIHRoZSBmaXJzdCBDRCBhbnl3YXkuXG4gICAgY29uc3QgcmVzdWx0VmlldyA9IGdldEl0ZW1WaWV3Um9vdCh2aWV3UmVmKTtcbiAgICByZXN1bHRWaWV3W05HX1ZJRVddID0gdmlld1JlZjtcbiAgICBpZiAodGhpcy5vbkNyZWF0ZSkge1xuICAgICAgdGhpcy5vbkNyZWF0ZShyZXN1bHRWaWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFZpZXc7XG4gIH1cbiAgdXBkYXRlKHZpZXc6IFZpZXcsIGNvbnRleHQ/OiB7IGluZGV4OiBudW1iZXI7IGRhdGE6IFQgfSk6IHZvaWQge1xuICAgIGNvbnN0IHZpZXdSZWYgPSB0aGlzLmdldEVtYmVkZGVkVmlld1JlZih2aWV3KTtcbiAgICB0aGlzLnNldHVwSXRlbUNvbnRleHQoY29udGV4dCwgdmlld1JlZik7XG4gICAgdmlld1JlZj8uZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG4gIGF0dGFjaCh2aWV3OiBWaWV3KTogdm9pZCB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICAgIHZpZXdSZWY/LnJlYXR0YWNoKCk7XG4gICAgdmlld1JlZj8uZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG4gIGRldGFjaCh2aWV3OiBWaWV3KTogdm9pZCB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICAgIHZpZXdSZWY/LmRldGFjaCgpO1xuICB9XG4gIGRpc3Bvc2UodmlldzogVmlldyk6IHZvaWQge1xuICAgIGNvbnN0IHZpZXdSZWYgPSB0aGlzLmdldEVtYmVkZGVkVmlld1JlZih2aWV3KTtcbiAgICB2aWV3UmVmPy5kZXN0cm95KCk7XG4gIH1cblxuICBnZXRFbWJlZGRlZFZpZXdSZWYodmlldzogVmlldyk6IEVtYmVkZGVkVmlld1JlZjxJdGVtQ29udGV4dDxUPj4gfCB1bmRlZmluZWQge1xuICAgIGxldCB2aWV3UmVmID0gdmlld1tOR19WSUVXXTtcblxuICAgIC8vIEdldHRpbmcgYW5ndWxhciB2aWV3IGZyb20gb3JpZ2luYWwgZWxlbWVudCAoaW4gY2FzZXMgd2hlbiBQcm94eVZpZXdDb250YWluZXJcbiAgICAvLyBpcyB1c2VkIE5hdGl2ZVNjcmlwdCBpbnRlcm5hbGx5IHdyYXBzIGl0IGluIGEgU3RhY2tMYXlvdXQpXG4gICAgaWYgKCF2aWV3UmVmICYmIHZpZXcgaW5zdGFuY2VvZiBMYXlvdXRCYXNlICYmIHZpZXcuZ2V0Q2hpbGRyZW5Db3VudCgpID4gMCkge1xuICAgICAgdmlld1JlZiA9IHZpZXcuZ2V0Q2hpbGRBdCgwKVtOR19WSUVXXTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdSZWY7XG4gIH1cblxuICBpc1ZhbGlkKHZpZXc6IFZpZXcpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldEVtYmVkZGVkVmlld1JlZih2aWV3KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJdGVtQ29udGV4dCh7IGluZGV4LCBkYXRhIH06IHsgaW5kZXg6IG51bWJlcjsgZGF0YTogVCB9LCBvbGRWaWV3PzogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+Pik6IEl0ZW1Db250ZXh0PFQ+IHtcbiAgICBjb25zdCBjb250ZXh0OiBJdGVtQ29udGV4dDxUPiA9IG9sZFZpZXcgPyBvbGRWaWV3LmNvbnRleHQgOiBuZXcgSXRlbUNvbnRleHQ8VD4oKTtcbiAgICBjb250ZXh0LiRpbXBsaWNpdCA9IGRhdGE7XG4gICAgY29udGV4dC5pdGVtID0gZGF0YTtcbiAgICBjb250ZXh0LmluZGV4ID0gaW5kZXg7XG4gICAgY29udGV4dC5ldmVuID0gaW5kZXggJSAyID09PSAwO1xuICAgIGNvbnRleHQub2RkID0gIWNvbnRleHQuZXZlbjtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldHVwSXRlbVZpZXdBcmdzPFQ+IHtcbiAgdmlldzogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+PjtcbiAgbmF0aXZlRWxlbWVudDogVmlldztcbiAgZGF0YTogVDtcbiAgaW5kZXg6IG51bWJlcjtcbiAgY29udGV4dDogSXRlbUNvbnRleHQ8VD47XG59XG5cbkBDb21wb25lbnQoe1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L2NvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ0xpc3RWaWV3JyxcbiAgdGVtcGxhdGU6IGA8RGV0YWNoZWRDb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAjbG9hZGVyPjwvbmctY29udGFpbmVyPlxuICA8L0RldGFjaGVkQ29udGFpbmVyPmAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFRFTVBMQVRFRF9JVEVNU19DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExpc3RWaWV3Q29tcG9uZW50KSB9XSxcbn0pXG5leHBvcnQgY2xhc3MgTGlzdFZpZXdDb21wb25lbnQ8VCA9IGFueT4gaW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudEluaXQsIFRlbXBsYXRlZEl0ZW1zSG9zdCB7XG4gIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpOiBMaXN0VmlldyB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3O1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMgPSBpbmplY3QoSXRlcmFibGVEaWZmZXJzKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmID0gaW5qZWN0KENoYW5nZURldGVjdG9yUmVmKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiA9IGluamVjdChFbGVtZW50UmVmKTtcblxuICAvLyBJIGJlbGlldmUgdGhpcyBvbmx5IGV4aXN0cyBzbyB0aGlzIGNhbiBiZSBpbmhlcml0ZWQgYW5kIHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQuXG4gIHByb3RlY3RlZCB0ZW1wbGF0ZWRJdGVtc1ZpZXc6IExpc3RWaWV3ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICBwcm90ZWN0ZWQgX2l0ZW1zOiBUW10gfCBPYnNlcnZhYmxlQXJyYXk8VD47XG4gIHByb3RlY3RlZCBfZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPjtcbiAgcHJvdGVjdGVkIF90ZW1wbGF0ZU1hcDogTWFwPHN0cmluZywgTnNUZW1wbGF0ZWRJdGVtPFQ+PjtcbiAgcHJvdGVjdGVkIF92aWV3VG9UZW1wbGF0ZTogV2Vha01hcDxWaWV3LCBzdHJpbmc+ID0gbmV3IFdlYWtNYXA8Vmlldywgc3RyaW5nPigpO1xuXG4gIEBWaWV3Q2hpbGQoJ2xvYWRlcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0pIGxvYWRlcjogVmlld0NvbnRhaW5lclJlZjtcblxuICBAT3V0cHV0KCkgcHVibGljIHNldHVwSXRlbVZpZXcgPSBuZXcgRXZlbnRFbWl0dGVyPFNldHVwSXRlbVZpZXdBcmdzPFQ+PigpO1xuXG4gIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSkgaXRlbVRlbXBsYXRlUXVlcnk6IFRlbXBsYXRlUmVmPEl0ZW1Db250ZXh0PFQ+PjtcblxuICBmYWxsYmFja0l0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8SXRlbUNvbnRleHQ8VD4+O1xuXG4gIEBJbnB1dCgpXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gIH1cblxuICBzZXQgaXRlbXModmFsdWU6IFRbXSB8IE9ic2VydmFibGVBcnJheTxUPikge1xuICAgIHRoaXMuX2l0ZW1zID0gdmFsdWU7XG4gICAgbGV0IG5lZWREaWZmZXIgPSB0cnVlO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9ic2VydmFibGVBcnJheSkge1xuICAgICAgbmVlZERpZmZlciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobmVlZERpZmZlciAmJiAhdGhpcy5fZGlmZmVyICYmIGlzTGlzdExpa2VJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVycy5maW5kKHRoaXMuX2l0ZW1zKS5jcmVhdGUoKF9pbmRleCwgaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3Lml0ZW1zID0gdGhpcy5faXRlbXM7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgX2l0ZXJhYmxlRGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgX2l0ZXJhYmxlRGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBfbmdab25lOiBOZ1pvbmUpO1xuICBjb25zdHJ1Y3RvcigpO1xuICAvLyB0aGlzIGVsZW1lbnRSZWYgaXMgb25seSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmPzogRWxlbWVudFJlZikge1xuICAgIGlmIChfZWxlbWVudFJlZikge1xuICAgICAgdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXcgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKCdUZW1wbGF0ZWRJdGVtc1ZpZXcubmdBZnRlckNvbnRlbnRJbml0KCknKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEl0ZW1UZW1wbGF0ZXMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl90ZW1wbGF0ZU1hcCkge1xuICAgICAgdGhpcy5fdGVtcGxhdGVNYXAuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldEl0ZW1UZW1wbGF0ZXMoKSB7XG4gICAgLy8gVGhlIGl0ZW1UZW1wbGF0ZVF1ZXJ5IG1heSBiZSBjaGFuZ2VkIGFmdGVyIGxpc3QgaXRlbXMgYXJlIGFkZGVkIHRoYXQgY29udGFpbiA8dGVtcGxhdGU+IGluc2lkZSxcbiAgICAvLyBzbyBjYWNoZSBhbmQgdXNlIG9ubHkgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRvIGF2b2lkIGVycm9ycy5cbiAgICB0aGlzLmZhbGxiYWNrSXRlbVRlbXBsYXRlID0gdGhpcy5pdGVtVGVtcGxhdGVRdWVyeTtcbiAgICBpZiAodGhpcy5mYWxsYmFja0l0ZW1UZW1wbGF0ZSAmJiAhdGhpcy5fdGVtcGxhdGVNYXA/LmhhcygnZGVmYXVsdCcpKSB7XG4gICAgICAvLyBhcHBhcmVudGx5IHlvdSBjYW4gY3JlYXRlIGEgQ29yZSBMaXN0VmlldyB3aXRob3V0IGEgdGVtcGxhdGUuLi5cbiAgICAgIC8vIHdlIGFsc28gYWRkIGEgZmFsbGJhY2sgZGVmYXVsdCBmb3Igd2hlbiB0aGUgdXNlciBzZXRzIG11bHRpcGxlIHRlbXBsYXRlcyBidXQgbm8gdGVtcGxhdGVTZWxlY3RvclxuICAgICAgdGhpcy5yZWdpc3RlclRlbXBsYXRlKCdkZWZhdWx0JywgdGhpcy5mYWxsYmFja0l0ZW1UZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RlbXBsYXRlTWFwKSB7XG4gICAgICAvLyBzb21ldGltZXMgdGVtcGxhdGVzIGFyZSByZWdpc3RlcmVkIGJlZm9yZSBsb2FkZXIgaXMgcmVhZHksIHNvIHdlIHVwZGF0ZSBoZXJlXG4gICAgICB0aGlzLl90ZW1wbGF0ZU1hcC5mb3JFYWNoKCh0KSA9PiAodC5sb2NhdGlvbiA9IHRoaXMubG9hZGVyKSk7XG4gICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coJ1NldHRpbmcgdGVtcGxhdGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlczogS2V5ZWRUZW1wbGF0ZVtdID0gW107XG4gICAgICB0aGlzLl90ZW1wbGF0ZU1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHRlbXBsYXRlcy5wdXNoKHtcbiAgICAgICAgICBjcmVhdGVWaWV3OiAoKSA9PiBudWxsLCAvLyB3ZSdsbCBoYW5kbGUgY3JlYXRpb24gbGF0ZXIsIG90aGVyd2lzZSBjb3JlIHdpbGwgY3JlYXRlIGFuIGludmFsaWQgdGVtcGxhdGVcbiAgICAgICAgICBrZXksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRlbXBsYXRlZEl0ZW1zVmlldy5pdGVtVGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWdpc3RlclRlbXBsYXRlKGtleTogc3RyaW5nLCB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SXRlbUNvbnRleHQ8VD4+KSB7XG4gICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICBOYXRpdmVTY3JpcHREZWJ1Zy5saXN0Vmlld0xvZyhgcmVnaXN0ZXJUZW1wbGF0ZSBmb3Iga2V5OiAke2tleX0sICR7dGhpcy5sb2FkZXJ9YCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90ZW1wbGF0ZU1hcCkge1xuICAgICAgdGhpcy5fdGVtcGxhdGVNYXAgPSBuZXcgTWFwPHN0cmluZywgTnNUZW1wbGF0ZWRJdGVtPFQ+PigpO1xuICAgIH1cblxuICAgIHRoaXMuX3RlbXBsYXRlTWFwLnNldChrZXksIG5ldyBOc1RlbXBsYXRlZEl0ZW08VD4odGVtcGxhdGUsIHRoaXMubG9hZGVyLCAodikgPT4gdGhpcy5fdmlld1RvVGVtcGxhdGUuc2V0KHYsIGtleSkpKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2l0ZW1Mb2FkaW5nJywgWyckZXZlbnQnXSlcbiAgQHByb2ZpbGVcbiAgcHVibGljIG9uSXRlbUxvYWRpbmcoYXJnczogSXRlbUV2ZW50RGF0YSkge1xuICAgIGlmICghdGhpcy5fdGVtcGxhdGVNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgY29uc3QgbHZpZXc6IExpc3RWaWV3ID0gPExpc3RWaWV3PmFyZ3Mub2JqZWN0O1xuICAgIGNvbnN0IGl0ZW1zID0gbHZpZXcuaXRlbXM7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSAnZ2V0SXRlbScgaW4gaXRlbXMgJiYgdHlwZW9mIGl0ZW1zLmdldEl0ZW0gPT09ICdmdW5jdGlvbicgPyBpdGVtcy5nZXRJdGVtKGluZGV4KSA6IGl0ZW1zW2luZGV4XTtcblxuICAgIGxldCB0ZW1wbGF0ZTogTnNUZW1wbGF0ZWRJdGVtPFQ+O1xuXG4gICAgaWYgKGFyZ3Mudmlldykge1xuICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKGBvbkl0ZW1Mb2FkaW5nOiAke2luZGV4fSAtIFJldXNpbmcgZXhpc3Rpbmcgdmlld2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGVtcGxhdGVLZXkgPSB0aGlzLl92aWV3VG9UZW1wbGF0ZS5nZXQoYXJncy52aWV3KTtcbiAgICAgIGlmICghdGVtcGxhdGVLZXkgJiYgYXJncy52aWV3IGluc3RhbmNlb2YgTGF5b3V0QmFzZSAmJiBhcmdzLnZpZXcuZ2V0Q2hpbGRyZW5Db3VudCgpID4gMCkge1xuICAgICAgICB0ZW1wbGF0ZUtleSA9IHRoaXMuX3ZpZXdUb1RlbXBsYXRlLmdldChhcmdzLnZpZXcuZ2V0Q2hpbGRBdCgwKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRlbXBsYXRlS2V5KSB7XG4gICAgICAgIC8vIHRoaXMgdGVtcGxhdGUgd2FzIG5vdCBjcmVhdGVkIGJ5IHVzXG4gICAgICAgIGlmIChOYXRpdmVTY3JpcHREZWJ1Zy5pc0xvZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3RXJyb3IoYFZpZXdSZWZlcmVuY2Ugbm90IGZvdW5kIGZvciBpdGVtICR7aW5kZXh9LiBWaWV3IHJlY3ljbGluZyBpcyBub3Qgd29ya2luZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVNYXAuZ2V0KHRlbXBsYXRlS2V5KTtcbiAgICAgIHRlbXBsYXRlLnVwZGF0ZShhcmdzLnZpZXcsIHsgaW5kZXgsIGRhdGE6IGN1cnJlbnRJdGVtIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIHNob3VsZCBuZXZlciBlbnRlciBpZiBpdCBjcmVhdGVzIHRoZSB2aWV3XG4gICAgICBjb25zdCB0ZW1wbGF0ZUtleSA9IHR5cGVvZiBsdmlldy5pdGVtVGVtcGxhdGVTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IGx2aWV3Lml0ZW1UZW1wbGF0ZVNlbGVjdG9yKGN1cnJlbnRJdGVtLCBpbmRleCwgaXRlbXMpIDogJ2RlZmF1bHQnO1xuICAgICAgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZU1hcC5nZXQodGVtcGxhdGVLZXkpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgICBOYXRpdmVTY3JpcHREZWJ1Zy5saXN0Vmlld0Vycm9yKGBUZW1wbGF0ZSBmb3Iga2V5ICcke3RlbXBsYXRlS2V5fScgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFyZ3MudmlldyA9IHRlbXBsYXRlLmNyZWF0ZSh7IGluZGV4LCBkYXRhOiBjdXJyZW50SXRlbSB9KTtcbiAgICB9XG4gICAgdGhpcy5zZXR1cFZpZXdSZWYodGVtcGxhdGUuZ2V0RW1iZWRkZWRWaWV3UmVmKGFyZ3MudmlldyksIGN1cnJlbnRJdGVtLCBpbmRleCwgYXJncy52aWV3KTtcblxuICAgIHRlbXBsYXRlLmF0dGFjaChhcmdzLnZpZXcpO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXR1cFZpZXdSZWYodmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+PiwgZGF0YTogVCwgaW5kZXg6IG51bWJlciwgbmF0aXZlRWxlbWVudDogVmlldyk6IHZvaWQge1xuICAgIGNvbnN0IGNvbnRleHQgPSB2aWV3UmVmLmNvbnRleHQ7XG4gICAgdGhpcy5zZXR1cEl0ZW1WaWV3Lm5leHQoeyB2aWV3OiB2aWV3UmVmLCBuYXRpdmVFbGVtZW50LCBkYXRhOiBkYXRhLCBpbmRleDogaW5kZXgsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKCduZ0RvQ2hlY2soKSAtIGV4ZWN1dGUgZGlmZmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9pdGVtcyBhcyBUW10pO1xuICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coJ25nRG9DaGVjaygpIC0gcmVmcmVzaCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXcucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBSb290TG9jYXRvciA9IChub2RlczogQXJyYXk8dW5rbm93bj4sIG5lc3RMZXZlbDogbnVtYmVyKSA9PiBWaWV3O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbVZpZXdSb290KHZpZXdSZWY6IEVtYmVkZGVkVmlld1JlZjx1bmtub3duPiwgcm9vdExvY2F0b3I6IFJvb3RMb2NhdG9yID0gZXh0cmFjdFNpbmdsZVZpZXdSZWN1cnNpdmUpOiBWaWV3IHtcbiAgY29uc3Qgcm9vdFZpZXcgPSByb290TG9jYXRvcih2aWV3UmVmLnJvb3ROb2RlcywgMCk7XG4gIHJldHVybiByb290Vmlldztcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9kaXJlY3RpdmUtc2VsZWN0b3JcbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuc1RlbXBsYXRlS2V5XSxbbnNUZW1wbGF0ZUtleXNdJyB9KVxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlS2V5RGlyZWN0aXZlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8VD4sIEBIb3N0KCkgQEluamVjdChURU1QTEFURURfSVRFTVNfQ09NUE9ORU5UKSBwcml2YXRlIGNvbXA6IFRlbXBsYXRlZEl0ZW1zSG9zdDxUPikge31cblxuICBASW5wdXQoKVxuICBzZXQgbnNUZW1wbGF0ZUtleSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuY29tcCAmJiB0aGlzLnRlbXBsYXRlUmVmKSB7XG4gICAgICB0aGlzLmNvbXAucmVnaXN0ZXJUZW1wbGF0ZSh2YWx1ZSwgdGhpcy50ZW1wbGF0ZVJlZik7XG4gICAgfVxuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBuc1RlbXBsYXRlS2V5cyh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgLy8gc2luZ2xlIHRlbXBsYXRlIHdpdGggbXVsdGlwbGUga2V5c1xuICAgIGlmICh0aGlzLmNvbXAgJiYgdGhpcy50ZW1wbGF0ZVJlZiAmJiB2YWx1ZXMpIHtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdGhpcy5jb21wLnJlZ2lzdGVyVGVtcGxhdGUodmFsdWUsIHRoaXMudGVtcGxhdGVSZWYpKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==